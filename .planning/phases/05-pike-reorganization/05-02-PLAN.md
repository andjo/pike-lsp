---
phase: 05-pike-reorganization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike
  - pike-scripts/LSP.pmod/Intelligence.pmod/TypeAnalysis.pike
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Resolution class contains handle_resolve and handle_resolve_stdlib handlers"
    - "StdlibResolver is part of Resolution.pike (not separate file)"
    - "TypeAnalysis class contains handle_get_inherited and AutoDoc parsing"
    - "Both classes use create(object ctx) constructor pattern"
    - "Shared helpers (get_module_path, read_source_file) are in Resolution.pmod or module.pmod"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike"
      provides: "Resolution class with name resolution and stdlib introspection"
      min_lines: 400
    - path: "pike-scripts/LSP.pmod/Intelligence.pmod/TypeAnalysis.pike"
      provides: "TypeAnalysis class with inheritance and AutoDoc parsing"
      min_lines: 350
  key_links:
    - from: "pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike"
      to: "pike-scripts/LSP.pmod/Cache"
      via: "Cache.get and Cache.put for stdlib cache"
      pattern: "Cache\.(get|put)"
    - from: "pike-scripts/LSP.pmod/Intelligence.pmod/TypeAnalysis.pike"
      to: "pike-scripts/LSP.pmod/Intelligence.pmod/module.pmod"
      via: "AutoDoc helper functions from module.pmod"
      pattern: "extract_autodoc_comments|process_inline_markup"
---

<objective>
Create Resolution.pike and TypeAnalysis.pike classes to complete the Intelligence.pmod split.

Purpose: Split the remaining Intelligence.pike handlers into Resolution.pike (module resolution, stdlib introspection) and TypeAnalysis.pike (inheritance traversal, AutoDoc parsing).
Output: Intelligence.pmod with 4 files total: module.pmod, Introspection.pike, Resolution.pike, TypeAnalysis.pike
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Phase context
@.planning/phases/05-pike-reorganization/05-CONTEXT.md
@.planning/phases/05-pike-reorganization/05-RESEARCH.md
@.planning/phases/05-pike-reorganization/05-01-SUMMARY.md

# Source files to split
@pike-scripts/LSP.pmod/Intelligence.pike
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Resolution.pike with Resolution class</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike</files>
  <action>
    Create Resolution.pike with class Resolution that contains:

    1. Private fields:
       - object context
       - mapping(string:int) resolving_modules - circular dependency guard
       - constant BOOTSTRAP_MODULES - modules that can't be resolved during introspection
       - constant Cache = LSP.Cache;

    2. void create(object ctx) constructor

    3. Mapping handlers (all with catch/LSPError pattern):
       - handle_resolve(mapping params) - Resolve module path to file location
       - handle_resolve_stdlib(mapping params) - Resolve stdlib module with documentation

    4. Protected helpers:
       - get_module_path(mixed resolved) - Get source path from resolved module
       - read_source_file(string path, void|int max_bytes) - Safe file reading avoiding circular dep
       - parse_stdlib_documentation(string source_path) - Parse AutoDoc from source
       - merge_documentation(mapping introspection, mapping docs) - Merge docs into symbols

    Handler pattern:
    - Check BOOTSTRAP_MODULES guard for stdlib resolution
    - Use resolving_modules set to detect circular dependencies
    - Check LSP.Cache.get("stdlib_cache", module_path) before resolving
    - Use LSP.Cache.put("stdlib_cache", module_path, result) after resolving
    - On error: return LSP.module.LSPError(-32000, describe_error(err))->to_response()

    For parse_stdlib_documentation:
    - Use extract_autodoc_comments from module.pmod
    - Use extract_symbol_name from module.pmod
    - Call merge_documentation to combine docs with introspection

    DO NOT include (these go to TypeAnalysis.pike):
    - handle_get_inherited (inheritance traversal)
    - parse_autodoc, parse_autodoc_impl (AutoDoc tokenization)
    - save_text_buffer, format_group_as_text (AutoDoc output formatting)
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Intelligence.Resolution"); if (programp(m)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>Resolution class with handle_resolve and handle_resolve_stdlib</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeAnalysis.pike with TypeAnalysis class</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pmod/TypeAnalysis.pike</files>
  <action>
    Create TypeAnalysis.pike with class TypeAnalysis that contains:

    1. Private object context field

    2. void create(object ctx) constructor

    3. Mapping handler:
       - handle_get_inherited(mapping params) - Get inherited members from parent classes

    4. Protected helpers for AutoDoc parsing:
       - parse_autodoc(string doc) - Entry point with error handling
       - parse_autodoc_impl(string doc) - Core AutoDoc tokenization logic
       - save_text_buffer(mapping result, string section, string param, array buffer)
       - format_group_as_text(string group_type, array items)

    5. Uses helper functions from module.pmod:
       - extract_autodoc_comments(code) - for documentation extraction
       - process_inline_markup(text) - for markdown conversion

    Handler pattern:
    - Use master()->resolv(class_name) to resolve class
    - Use Program.inherit_list(prog) to get parent programs
    - Call .Introspection (sibling class) or introspect_program directly
    - Wrap in catch with LSPError response on error

    parse_autodoc implementation:
    - Uses Tools.AutoDoc.DocParser.splitDocBlock for tokenization
    - Token types: 1=METAKEYWORD, 3=DELIMITERKEYWORD, 4=BEGINGROUP, 6=ENDGROUP, 8=TEXTTOKEN
    - Processes @param, @returns, @throws, @note, @bugs, @deprecated, @example, @seealso
    - Handles groups: @array, @mapping, @multiset, @dl
    - Calls process_inline_markup for text processing

    Note: This file will be larger (~350+ lines) due to AutoDoc parsing complexity
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Intelligence.TypeAnalysis"); if (programp(m)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>TypeAnalysis class with handle_get_inherited and AutoDoc parsing</done>
</task>

<task type="auto">
  <name>Task 3: Update module.pmod and verify all classes load</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pmod/module.pmod</files>
  <action>
    Update module.pmod if needed to ensure all helper functions are present.
    Verify that all four classes load correctly:

    Verification command:
    pike -e '
      master()->add_module_path("pike-scripts");
      mixed mod = master()->resolv("LSP.Intelligence");
      if (!mod) { werror("FAIL: Module not loaded\n"); exit(1); }
      werror("OK: LSP.Intelligence loaded\n");

      array(string) classes = ({"Introspection", "Resolution", "TypeAnalysis"});
      foreach (classes, string cls_name) {
        mixed cls = mod[cls_name];
        if (!programp(cls)) {
          werror("FAIL: %s class not found\n", cls_name);
          exit(1);
        }
        werror("OK: %s class found\n", cls_name);
      }

      // Verify module.pmod functions
      array(string) funcs = ({"extract_autodoc_comments", "extract_symbol_name",
                              "process_inline_markup", "replace_markup"});
      foreach (funcs, string func_name) {
        if (!functionp(mod[func_name])) {
          werror("FAIL: %s function not found\n", func_name);
          exit(1);
        }
        werror("OK: %s function accessible\n", func_name);
      }
    '

    Create summary at .planning/phases/05-pike-reorganization/05-02-SUMMARY.md
  </action>
  <verify>All classes load, module.pmod functions accessible</verify>
  <done>Intelligence.pmod complete with 4 files</done>
</task>

</tasks>

<verification>
## Module Loading Tests

```bash
pike -e '
  master()->add_module_path("pike-scripts");
  mixed mod = master()->resolv("LSP.Intelligence");
  if (!mod) { exit(1); }
  foreach (({"Introspection", "Resolution", "TypeAnalysis"}), string cls) {
    if (!programp(mod[cls])) { werror("Missing: %s\n", cls); exit(1); }
  }
  werror("PASS: All Intelligence classes loaded\n");
'
```

## File Structure Verification

- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/module.pmod
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/TypeAnalysis.pike
</verification>

<success_criteria>
1. Resolution.pike exists with handle_resolve and handle_resolve_stdlib
2. TypeAnalysis.pike exists with handle_get_inherited and AutoDoc parsing
3. All classes use create(object ctx) constructor
4. All handlers use catch/LSPError error pattern
5. StdlibResolver is part of Resolution.pike (not separate)
6. Original Intelligence.pike still exists (backup, not deleted yet)
</success_criteria>

<output>
After completion, create `.planning/phases/05-pike-reorganization/05-02-SUMMARY.md`
</output>
