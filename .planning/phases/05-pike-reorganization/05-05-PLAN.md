---
phase: 05-pike-reorganization
plan: 05
type: execute
wave: 4
depends_on: ["05-02", "05-04"]
files_modified:
  - pike-scripts/LSP.pmod/Intelligence.pike
  - pike-scripts/LSP.pmod/Analysis.pike
  - pike-scripts/analyzer.pike
  - test/tests/module-load-tests.pike
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Old Intelligence.pike and Analysis.pike are deleted or replaced with delegating stubs"
    - "analyzer.pike Context uses new .pmod classes correctly"
    - "Module loading tests verify LSP.Intelligence.* and LSP.Analysis.* classes"
    - "E2E smoke test passes (pike compiles, introspect works)"
    - "All handlers still work through the new structure"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Intelligence.pike"
      provides: "Delegating class that forwards to new .pmod classes OR deleted if .pmod resolves directly"
    - path: "pike-scripts/LSP.pmod/Analysis.pike"
      provides: "Delegating class that forwards to new .pmod classes OR deleted if .pmod resolves directly"
    - path: "test/tests/module-load-tests.pike"
      provides: "Updated module loading tests for new structure"
  key_links:
    - from: "pike-scripts/analyzer.pike"
      to: "pike-scripts/LSP.pmod/Intelligence.pmod/*"
      via: "master()->resolv() loads Intelligence.pmod as module"
      pattern: "master\(\)->resolv\(\"LSP\.Intelligence"
    - from: "pike-scripts/analyzer.pike"
      to: "pike-scripts/LSP.pmod/Analysis.pmod/*"
      via: "master()->resolv() loads Analysis.pmod as module"
      pattern: "master\(\)->resolv\(\"LSP\.Analysis"
---

<objective>
Replace original Intelligence.pike and Analysis.pike with backward-compatible stubs, update analyzer.pike Context, and verify E2E functionality.

Purpose: Complete the Pike reorganization by ensuring backward compatibility (existing code using LSP.Intelligence and LSP.Analysis continues to work), update the module loading tests, and verify the full LSP pipeline works end-to-end.
Output: Original single-file classes replaced, tests updated, E2E verification passing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Phase context
@.planning/phases/05-pike-reorganization/05-CONTEXT.md
@.planning/phases/05-pike-reorganization/05-RESEARCH.md
@.planning/phases/05-pike-reorganization/05-02-SUMMARY.md
@.planning/phases/05-pike-reorganization/05-04-SUMMARY.md

# Files to modify
@pike-scripts/analyzer.pike
@test/tests/module-load-tests.pike
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backward-compatible Intelligence.pike delegating class</name>
  <files>pike-scripts/LSP.pmod/Intelligence.pike</files>
  <action>
    Replace the original Intelligence.pike (1,660 lines) with a compact delegating class.

    Key decision from RESEARCH.md Q1: Keep a delegating Intelligence class for backward compatibility.
    This allows analyzer.pike to continue using the existing pattern without changes.

    New Intelligence.pike structure:
    ```pike
    //! Intelligence.pike - Backward-compatible delegating class
    //!
    //! This class delegates to the new modular structure in Intelligence.pmod/
    //!
    //! After v2 reorganization:
    //! - Introspection.pike: Symbol extraction
    //! - Resolution.pike: Module resolution, stdlib introspection
    //! - TypeAnalysis.pike: Inheritance, AutoDoc parsing

    //! Import the modular classes
    // Note: When master()->resolv("LSP.Intelligence") is called,
    // Pike finds Intelligence.pmod/ directory first
    // This file provides the backward-compatible Intelligence class

    constant Cache = LSP.Cache;

    //! State tracking for stdlib resolution (circular dependency guard)
    private mapping(string:int) resolving_modules = ([]);
    private mapping(string:int) circular_refs = ([]);

    //! Bootstrap modules that can't be resolved during introspection
    constant BOOTSTRAP_MODULES = (<
        "Stdio", "String", "Array", "Mapping"
    >);

    //! Intelligence class - Delegates to specialized classes
    class Intelligence {
        private object introspection_handler;
        private object resolution_handler;
        private object type_analysis_handler;

        void create() {
            // Create instances of the specialized classes
            mixed introspection_class = master()->resolv("LSP.Intelligence.Introspection");
            mixed resolution_class = master()->resolv("LSP.Intelligence.Resolution");
            mixed type_analysis_class = master()->resolv("LSP.Intelligence.TypeAnalysis");

            if (introspection_class && programp(introspection_class)) {
                introspection_handler = introspection_class(0);
            }
            if (resolution_class && programp(resolution_class)) {
                resolution_handler = resolution_class(0);
            }
            if (type_analysis_class && programp(type_analysis_class)) {
                type_analysis_handler = type_analysis_class(0);
            }
        }

        //! Delegate introspect to Introspection class
        mapping handle_introspect(mapping params) {
            if (introspection_handler) {
                return introspection_handler->handle_introspect(params);
            }
            return LSP.module.LSPError(-32000, "Introspection handler not available")->to_response();
        }

        //! Delegate resolve to Resolution class
        mapping handle_resolve(mapping params) {
            if (resolution_handler) {
                return resolution_handler->handle_resolve(params);
            }
            return LSP.module.LSPError(-32000, "Resolution handler not available")->to_response();
        }

        //! Delegate resolve_stdlib to Resolution class
        mapping handle_resolve_stdlib(mapping params) {
            if (resolution_handler) {
                return resolution_handler->handle_resolve_stdlib(params);
            }
            return LSP.module.LSPError(-32000, "Resolution handler not available")->to_response();
        }

        //! Delegate get_inherited to TypeAnalysis class
        mapping handle_get_inherited(mapping params) {
            if (type_analysis_handler) {
                return type_analysis_handler->handle_get_inherited(params);
            }
            return LSP.module.LSPError(-32000, "TypeAnalysis handler not available")->to_response();
        }
    }
    ```

    Important notes:
    1. When master()->resolv("LSP.Intelligence") is called, Pike finds Intelligence.pmod/ directory
    2. This file is resolved because it's inside the .pmod directory
    3. The Intelligence class provides backward compatibility
    4. Each handler delegates to the appropriate specialized class
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Intelligence"); if (m && m->Intelligence && programp(m->Intelligence)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>Intelligence.pike replaced with delegating class (~100 lines)</done>
</task>

<task type="auto">
  <name>Task 2: Create backward-compatible Analysis.pike delegating class</name>
  <files>pike-scripts/LSP.pmod/Analysis.pike</files>
  <action>
    Replace the original Analysis.pike (1,191 lines) with a compact delegating class.

    New Analysis.pike structure:
    ```pike
    //! Analysis.pike - Backward-compatible delegating class
    //!
    //! This class delegates to the new modular structure in Analysis.pmod/
    //!
    //! After v2 reorganization:
    //! - Diagnostics.pike: Uninitialized variable analysis
    //! - Completions.pike: Completion context analysis
    //! - Variables.pike: Find occurrences

    //! Analysis class - Delegates to specialized classes
    class Analysis {
        private object diagnostics_handler;
        private object completions_handler;
        private object variables_handler;

        void create() {
            // Create instances of the specialized classes
            mixed diagnostics_class = master()->resolv("LSP.Analysis.Diagnostics");
            mixed completions_class = master()->resolv("LSP.Analysis.Completions");
            mixed variables_class = master()->resolv("LSP.Analysis.Variables");

            if (diagnostics_class && programp(diagnostics_class)) {
                diagnostics_handler = diagnostics_class(0);
            }
            if (completions_class && programp(completions_class)) {
                completions_handler = completions_class(0);
            }
            if (variables_class && programp(variables_class)) {
                variables_handler = variables_class(0);
            }
        }

        //! Delegate analyze_uninitialized to Diagnostics class
        mapping handle_analyze_uninitialized(mapping params) {
            if (diagnostics_handler) {
                return diagnostics_handler->handle_analyze_uninitialized(params);
            }
            return (["result": (["diagnostics": ({}))]);
        }

        //! Delegate get_completion_context to Completions class
        mapping handle_get_completion_context(mapping params) {
            if (completions_handler) {
                return completions_handler->handle_get_completion_context(params);
            }
            return (["result": (["context": "none", "objectName": "", "prefix": "", "operator": ""])]);
        }

        //! Delegate find_occurrences to Variables class
        mapping handle_find_occurrences(mapping params) {
            if (variables_handler) {
                return variables_handler->handle_find_occurrences(params);
            }
            return LSP.module.LSPError(-32000, "Variables handler not available")->to_response();
        }
    }
    ```

    Note: This is smaller than Intelligence.pike because Analysis has only 3 handlers vs 4
  </action>
  <verify>pike -e 'master()->add_module_path("pike-scripts"); mixed m = master()->resolv("LSP.Analysis"); if (m && m->Analysis && programp(m->Analysis)) { werror("OK\n"); } else { werror("FAIL\n"); exit(1); }'</verify>
  <done>Analysis.pike replaced with delegating class (~80 lines)</done>
</task>

<task type="auto">
  <name>Task 3: Verify analyzer.pike Context works with new structure</name>
  <files></files>
  <action>
    Verify that analyzer.pike can still instantiate Intelligence and Analysis classes
    using the existing pattern.

    Read analyzer.pike to confirm the Context creation pattern:
    grep -A 10 "IntelligenceClass\|AnalysisClass" pike-scripts/analyzer.pike

    The existing pattern should be:
    - Program IntelligenceClass = master()->resolv("LSP.Intelligence")->Intelligence;
    - Program AnalysisClass = master()->resolv("LSP.Analysis")->Analysis;

    Test that instantiation works:
    pike -e '
      master()->add_module_path("pike-scripts");

      // Test Intelligence
      mixed intel_mod = master()->resolv("LSP.Intelligence");
      if (!intel_mod) { werror("FAIL: LSP.Intelligence not resolved\n"); exit(1); }
      werror("OK: LSP.Intelligence resolved\n");

      mixed intel_cls = intel_mod->Intelligence;
      if (!programp(intel_cls)) { werror("FAIL: Intelligence class not found\n"); exit(1); }
      werror("OK: Intelligence class found\n");

      object intel = intel_cls();
      werror("OK: Intelligence instantiated\n");

      // Test Analysis
      mixed analysis_mod = master()->resolv("LSP.Analysis");
      if (!analysis_mod) { werror("FAIL: LSP.Analysis not resolved\n"); exit(1); }
      werror("OK: LSP.Analysis resolved\n");

      mixed analysis_cls = analysis_mod->Analysis;
      if (!programp(analysis_cls)) { werror("FAIL: Analysis class not found\n"); exit(1); }
      werror("OK: Analysis class found\n");

      object analysis = analysis_cls();
      werror("OK: Analysis instantiated\n");

      werror("PASS: All handlers accessible\n");
    '

    If verification passes, no changes to analyzer.pike are needed.
  </action>
  <verify>analyzer.pike can instantiate Intelligence and Analysis classes</verify>
  <done>analyzer.pike Context works with new structure (no changes needed)</done>
</task>

<task type="auto">
  <name>Task 4: Update module-load-tests.pike for new structure</name>
  <files>test/tests/module-load-tests.pike</files>
  <action>
    Update test/tests/module-load-tests.pike to verify the new modular structure.

    Add new test function test_modular_intelligence_structure() to verify:
    1. LSP.Intelligence module loads
    2. LSP.Intelligence.Introspection class exists
    3. LSP.Intelligence.Resolution class exists
    4. LSP.Intelligence.TypeAnalysis class exists
    5. LSP.Intelligence.Intelligence class exists (backward compat)

    Add new test function test_modular_analysis_structure() to verify:
    1. LSP.Analysis module loads
    2. LSP.Analysis.Diagnostics class exists
    3. LSP.Analysis.Completions class exists
    4. LSP.Analysis.Variables class exists
    5. LSP.Analysis.Analysis class exists (backward compat)

    Update existing test_critical_exports() to also check:
    - LSP.Intelligence.Introspection class
    - LSP.Intelligence.Resolution class
    - LSP.Intelligence.TypeAnalysis class
    - LSP.Analysis.Diagnostics class
    - LSP.Analysis.Completions class
    - LSP.Analysis.Variables class

    Add to main() test runner:
    run_test(test_modular_intelligence_structure, "Modular Intelligence structure");
    run_test(test_modular_analysis_structure, "Modular Analysis structure");

    Pattern for new tests:
    ```pike
    void test_modular_intelligence_structure() {
        mixed mod = master()->resolv("LSP.Intelligence");
        if (!mod) error("LSP.Intelligence module not found\n");

        array(string) classes = ({
            "Introspection", "Resolution", "TypeAnalysis", "Intelligence"
        });

        foreach (classes, string cls_name) {
            mixed cls = mod[cls_name];
            if (!cls) error("LSP.Intelligence.%s not found\n", cls_name);
            if (!programp(cls)) error("LSP.Intelligence.%s is not a class\n", cls_name);
        }
    }
    ```
  </action>
  <verify>pike test/tests/module-load-tests.pike runs and passes</verify>
  <done>module-load-tests.pike updated with new structure tests</done>
</task>

<task type="auto">
  <name>Task 5: Run E2E smoke test to verify LSP functionality</name>
  <files></files>
  <action>
    Run the mandatory E2E verification from CLAUDE.md before committing.

    Step 1: Verify Pike compiles
    pike -e 'compile_file("pike-scripts/analyzer.pike");'

    Step 2: Test introspect through the analyzer
    echo '{"jsonrpc":"2.0","id":1,"method":"introspect","params":{"code":"int x;","filename":"test.pike"}}' \
      | timeout 5 pike pike-scripts/analyzer.pike 2>&1

    Expected: JSON response with "result" containing symbols, not timeout or error

    Step 3: Run module loading tests
    pike test/tests/module-load-tests.pike

    Expected: All tests pass

    Step 4: Verify line counts are reduced
    wc -l pike-scripts/LSP.pmod/Intelligence.pike
    wc -l pike-scripts/LSP.pmod/Analysis.pike
    wc -l pike-scripts/LSP.pmod/Intelligence.pmod/*.pike
    wc -l pike-scripts/LSP.pmod/Intelligence.pmod/*.pmod
    wc -l pike-scripts/LSP.pmod/Analysis.pmod/*.pike
    wc -l pike-scripts/LSP.pmod/Analysis.pmod/*.pmod

    Expected:
    - Intelligence.pike: ~100 lines (down from 1660)
    - Analysis.pike: ~80 lines (down from 1191)
    - Each .pike file in .pmod: 100-500 lines

    Create summary at .planning/phases/05-pike-reorganization/05-05-SUMMARY.md
  </action>
  <verify>
    1. Pike compiles without errors
    2. Introspect returns valid JSON with symbols
    3. Module loading tests pass
    4. Line counts confirm reduction
  </verify>
  <done>E2E smoke test passes, Pike reorganization complete</done>
</task>

</tasks>

<verification>
## E2E Smoke Test (MANDATORY before commit)

```bash
# 1. Pike compiles
pike -e 'compile_file("pike-scripts/analyzer.pike");'

# 2. Introspect works
echo '{"jsonrpc":"2.0","id":1,"method":"introspect","params":{"code":"int x;","filename":"test.pike"}}' \
  | timeout 5 pike pike-scripts/analyzer.pike

# 3. Module tests pass
pike test/tests/module-load-tests.pike
```

## Line Count Verification

```bash
# Should show significant reduction
wc -l pike-scripts/LSP.pmod/Intelligence.pike
wc -l pike-scripts/LSP.pmod/Analysis.pike
wc -l pike-scripts/LSP.pmod/Intelligence.pmod/*.pike
wc -l pike-scripts/LSP.pmod/Analysis.pmod/*.pike
```

## Final Structure

- [ ] pike-scripts/LSP.pmod/Intelligence.pike (~100 lines, delegating)
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/module.pmod
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/Introspection.pike
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/Resolution.pike
- [ ] pike-scripts/LSP.pmod/Intelligence.pmod/TypeAnalysis.pike
- [ ] pike-scripts/LSP.pmod/Analysis.pike (~80 lines, delegating)
- [ ] pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
- [ ] pike-scripts/LSP.pmod/Analysis.pmod/Diagnostics.pike
- [ ] pike-scripts/LSP.pmod/Analysis.pmod/Completions.pike
- [ ] pike-scripts/LSP.pmod/Analysis.pmod/Variables.pike
</verification>

<success_criteria>
1. Intelligence.pike: 1660 -> ~100 lines (94% reduction)
2. Analysis.pike: 1191 -> ~80 lines (93% reduction)
3. LSP.Intelligence.* classes all load via master()->resolv()
4. LSP.Analysis.* classes all load via master()->resolv()
5. E2E smoke test passes (introspect returns data)
6. Module loading tests pass with new structure
7. Related logic stays together (StdlibResolver in Resolution, Occurrences in Variables)
</success_criteria>

<output>
After completion, create `.planning/phases/05-pike-reorganization/05-05-SUMMARY.md`

This is the final plan of Phase 5. Upon completion:
1. Update ROADMAP.md to mark Phase 5 complete
2. Update STATE.md with final velocity metrics
3. Mark v2 milestone complete (all 5 phases done)
</output>
