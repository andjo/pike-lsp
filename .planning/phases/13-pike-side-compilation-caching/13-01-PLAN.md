---
phase: 13-pike-side-compilation-caching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pike-scripts/LSP.pmod/CompilationCache.pmod
autonomous: true

must_haves:
  truths:
    - "CompilationCache module exists in LSP.pmod"
    - "Cache stores compiled programs keyed by path + version string"
    - "Cache supports get/put/invalidate operations"
    - "Cache enforces MAX_CACHED_FILES limit with nuclear eviction"
    - "Cache tracks statistics (hits, misses, evictions)"
  artifacts:
    - path: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      provides: "File-based compilation cache infrastructure"
      min_lines: 100
      exports: ["get", "put", "invalidate", "invalidate_all", "get_stats", "clear"]
  key_links:
    - from: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      to: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      via: "master()->resolv('LSP.CompilationCache')"
      pattern: "CompilationCache.*get|put|invalidate"
---

<objective>
Create LSP.CompilationCache module for in-memory caching of compiled Pike programs

Purpose: Avoid recompiling unchanged code between requests by storing compiled programs in a nested mapping structure keyed by file path and content version (mtime:size for closed files, LSP version for open docs).

Output: CompilationCache.pmod module with get/put/invalidate API, nested cache structure, size limit enforcement, and statistics tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-pike-side-compilation-caching/13-CONTEXT.md
@.planning/phases/13-pike-side-compilation-caching/13-RESEARCH.md
@pike-scripts/LSP.pmod/Cache.pmod
@pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
</context>

<tasks>

<task type="auto">
  <name>Create CompilationCache module structure</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Create pike-scripts/LSP.pmod/CompilationCache.pmod with:

1. **Module documentation** (//! comments):
   - Purpose: Cache compiled programs by file path + version
   - Cache key format: path\0version where version is mtime\0size for closed files
   - O(1) invalidation via m_delete on outer key
   - Nuclear eviction at MAX_CACHED_FILES limit

2. **Constants**:
   ```pike
   constant MAX_CACHED_FILES = 500;
   ```

3. **Cache storage** (nested mapping per CONTEXT.md):
   ```pike
   // Outer key: file path
   // Inner key: version string (mtime\0size)
   private mapping(string:mapping(string:CompilationResult)) compilation_cache = ([]);
   ```

4. **CompilationResult class** (minimal viable per CONTEXT.md):
   ```pike
   class CompilationResult {
       program compiled_program;
       array(mapping) diagnostics;
       array(string) dependencies;  // Will be populated in 13-02
   }
   ```

5. **Statistics tracking**:
   ```pike
   private mapping(string:int) stats = ([
       "hits": 0,
       "misses": 0,
       "evictions": 0
   ]);
   ```

DO NOT implement dependency tracking yet (plan 13-02 handles that).
DO NOT integrate with handle_analyze yet (plan 13-03 handles that).
  </action>
  <verify>grep -q "class CompilationResult" pike-scripts/LSP.pmod/CompilationCache.pmod && grep -q "MAX_CACHED_FILES" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>CompilationCache.pmod exists with nested cache structure and CompilationResult class</done>
</task>

<task type="auto">
  <name>Implement cache operations (get, put, invalidate)</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Implement core cache operations:

1. **get(path, version_key)**:
   ```pike
   CompilationResult get(string path, string version_key) {
       if (compilation_cache[path] && compilation_cache[path][version_key]) {
           stats->hits++;
           return compilation_cache[path][version_key];
       }
       stats->misses++;
       return 0;  // Cache miss
   }
   ```

2. **put(path, version_key, result)** with nuclear eviction:
   ```pike
   void put(string path, string version_key, CompilationResult result) {
       // Check size limit - nuclear eviction if at capacity
       if (sizeof(compilation_cache) >= MAX_CACHED_FILES && !compilation_cache[path]) {
           compilation_cache = ([]);  // Nuclear eviction
           stats->evictions++;
       }

       if (!compilation_cache[path]) {
           compilation_cache[path] = ([]);
       }
       compilation_cache[path][version_key] = result;
   }
   ```

3. **invalidate(path)** - O(1) file invalidation:
   ```pike
   void invalidate(string path) {
       if (compilation_cache[path]) {
           m_delete(compilation_cache, path);
       }
   }
   ```

4. **invalidate_all()** - clear entire cache:
   ```pike
   void invalidate_all() {
       compilation_cache = ([]);
   }
   ```

5. **get_stats()** - return statistics copy:
   ```pike
   mapping get_stats() {
       return ([
           "hits": stats->hits,
           "misses": stats->misses,
           "evictions": stats->evictions,
           "size": sizeof(compilation_cache),
           "max_files": MAX_CACHED_FILES
       ]);
   }
   ```

Follow LSP.Cache.pmod patterns for error handling (graceful degradation, no crashes).
  </action>
  <verify>grep -q "CompilationResult get\|void put\|void invalidate\|mapping get_stats" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>All cache operations implemented with proper statistics tracking</done>
</task>

<task type="auto">
  <name>Add cache key generation helper</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Add cache key generation using dual-path strategy from RESEARCH.md:

```pike
//! Generate cache key for a file
//! @param path File path
//! @param lsp_version Optional LSP version number (for open documents)
//! @returns Cache key string or 0 if file doesn't exist
string make_cache_key(string path, void|int lsp_version) {
    // If LSP version provided (open document), use it directly
    if (lsp_version != undefined) {
        return sprintf("LSP:%d", lsp_version);
    }

    // Closed file: stat filesystem
    mapping st = file_stat(path);
    if (!st) {
        return 0;  // File deleted
    }

    // Use mtime\0size format per CONTEXT.md decision
    return sprintf("FS:%d\0%d", st->mtime, st->size);
}
```

Note: The \0 separator avoids escaping issues with colons in paths (Windows).

Import Stdio for file_stat at module level:
```pike
constant Stdio = Stdio;  // Ensure Stdio is available
```
  </action>
  <verify>grep -q "make_cache_key\|sprintf.*FS:\|sprintf.*LSP:" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>Cache key generation supports both LSP version and filesystem stat approaches</done>
</task>

</tasks>

<verification>
1. Module compiles: `pike -e 'mixed m = master()->resolv("LSP.CompilationCache"); werror("CompilationCache: %s\n", m ? "loaded" : "failed");'`
2. Verify nested structure: Check that cache uses `mapping(string:mapping(string:CompilationResult))`
3. Verify O(1) invalidation: Confirm `m_delete(cache, path)` removes all versions
4. Verify nuclear eviction: Test that cache clears when reaching MAX_CACHED_FILES
5. Verify statistics: Check that get_stats returns hits, misses, evictions, size
</verification>

<success_criteria>
1. CompilationCache module loads successfully via master()->resolv()
2. Cache stores and retrieves CompilationResult objects correctly
3. Cache key generation works for both open docs (LSP version) and closed files (stat)
4. Nuclear eviction triggers at MAX_CACHED_FILES limit
5. Statistics accurately track cache operations
</success_criteria>

<output>
After completion, create `.planning/phases/13-pike-side-compilation-caching/13-01-SUMMARY.md`
</output>
