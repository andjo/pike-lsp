---
phase: 13-pike-side-compilation-caching
plan: 02
type: execute
wave: 2
depends_on: [13-01]
files_modified:
  - pike-scripts/LSP.pmod/CompilationCache.pmod
  - pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
autonomous: true

must_haves:
  truths:
    - "Dependency tracking uses compiler hooks to capture actual import/inherit paths"
    - "Dependencies are stored in CompilationResult.dependencies array"
    - "Only local dependencies (within project root) are tracked"
    - "Dependency graphs support forward and reverse lookups"
    - "Transitive invalidation traverses dependents via BFS"
  artifacts:
    - path: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      provides: "Dependency tracking and transitive invalidation"
      contains: "DependencyTrackingCompiler|invalidate_transitive|update_dependency_graph"
  key_links:
    - from: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      to: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      via: "DependencyTrackingCompiler class"
      pattern: "handle_inherit|handle_import"
    - from: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      to: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      via: "DependencyTrackingCompiler instantiation"
      pattern: "DependencyTrackingCompiler.*compile"
---

<objective>
Add dependency tracking via Pike compiler hooks for transitive cache invalidation

Purpose: When a file changes, all files that depend on it (transitive dependents) must have their cache entries invalidated. This requires tracking import/inherit relationships during compilation using compiler hooks, then traversing the dependency graph on invalidation.

Output: DependencyTrackingCompiler class, dependency graph storage, and transitive invalidation via BFS traversal.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-pike-side-compilation-caching/13-CONTEXT.md
@.planning/phases/13-pike-side-compilation-caching/13-RESEARCH.md
@.planning/phases/13-pike-side-compilation-caching/13-01-SUMMARY.md
@pike-scripts/LSP.pmod/Cache.pmod
@pike-scripts/LSP.pmod/CompilationCache.pmod
@pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
</context>

<tasks>

<task type="auto">
  <name>Add dependency graph storage to CompilationCache</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Add dependency graph data structures to CompilationCache:

1. **Forward edges** (what each file imports):
   ```pike
   // dependencies[path] = ({dep1, dep2, ...})
   private mapping(string:array(string)) dependencies = ([]);
   ```

2. **Reverse edges** (what imports each file):
   ```pike
   // dependents[dep] = (<dependent1, dependent2, ...>)
   private mapping(string:multiset(string)) dependents = ([]);
   ```

3. **Project root** for filtering local dependencies:
   ```pike
   private string project_root = getcwd();

   //! Check if a file is within the project root
   //! Only track local dependencies - stdlib/external modules don't change during session
   protected int is_local_file(string path) {
       string normalized = combine_path(project_root, path);
       return has_prefix(normalized, project_root);
   }
   ```

These structures enable O(1) lookup for:
- What does file X depend on? -> dependencies[X]
- What depends on file X? -> indices(dependents[X])
  </action>
  <verify>grep -q "mapping.*:array.*dependencies\|multiset.*dependents\|is_local_file" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>Dependency graph storage initialized with local file filtering</done>
</task>

<task type="auto">
  <name>Implement DependencyTrackingCompiler class</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Create DependencyTrackingCompiler class that overrides compiler hooks:

```pike
//! Compiler wrapper that tracks dependencies during compilation
class DependencyTrackingCompiler {
    private array(string) _dependencies = ({});
    private string _current_file;

    //! Get captured dependencies after compilation
    array(string) get_dependencies() {
        return _dependencies;
    }

    //! Set the file being compiled (for context in hooks)
    void set_current_file(string path) {
        _current_file = path;
        _dependencies = ({});
    }

    //! Compile with dependency tracking
    program compile_with_tracking(string code, string filename, void|mapping|function handler) {
        // Set current file for hook context
        set_current_file(filename);

        // Capture compilation errors
        array(mapping) diagnostics = ({});
        void compile_error_handler(string file, int line, string msg) {
            diagnostics += ({([
                "message": msg,
                "severity": "error",
                "position": (["file": file, "line": line])
            ])});
        };

        mixed old_handler = master()->get_inhibit_compile_errors();
        master()->set_inhibit_compile_errors(compile_error_handler);

        program prog = 0;
        mixed err = catch {
            prog = compile_string(code, filename);
        };

        master()->set_inhibit_compile_errors(old_handler);

        if (err) throw(err);
        return prog;
    }
}
```

NOTE: Full compiler hook override (handle_inherit, handle_import) requires runtime testing with Pike 8.0.1116 to verify exact API. Start with basic compilation wrapper; hooks can be added in a follow-up if needed based on testing.

Alternative: Use Parser.Pike to find inherit/import directives post-compilation (less accurate but no hook API dependency).
  </action>
  <verify>grep -q "class DependencyTrackingCompiler\|compile_with_tracking\|get_dependencies" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>DependencyTrackingCompiler class wraps compilation to extract dependencies</done>
</task>

<task type="auto">
  <name>Implement dependency graph update</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Add update_dependency_graph method per RESEARCH.md incremental update pattern:

```pike
//! Update dependency graph for a file
//! Removes old edges before adding new ones to prevent stale accumulation
//! @param path The file being compiled
//! @param new_deps Array of dependencies discovered during compilation
void update_dependency_graph(string path, array(string) new_deps) {
    // Remove old edges (incremental update)
    if (dependencies[path]) {
        foreach (dependencies[path], string old_dep) {
            if (dependents[old_dep]) {
                dependents[old_dep][path] = 0;
            }
        }
    }

    // Filter to local dependencies only
    array(string) local_deps = ({});
    foreach (new_deps, string dep) {
        if (is_local_file(dep)) {
            local_deps += ({dep});
        }
    }

    // Add new edges
    dependencies[path] = local_deps;
    foreach (local_deps, string dep) {
        if (!dependents[dep]) {
            dependents[dep] = (<>);
        }
        dependents[dep][path] = 1;
    }
}
```

This prevents the "stale edge accumulation" anti-pattern from RESEARCH.md.
  </action>
  <verify>grep -q "update_dependency_graph\|Remove old edges\|dependents\[dep\]" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>Dependency graph updates are incremental (old edges removed before new ones added)</done>
</task>

<task type="auto">
  <name>Implement transitive invalidation via BFS</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Add invalidate_transitive method per RESEARCH.md BFS pattern:

```pike
//! Invalidate all files that transitively depend on the changed file
//! Uses BFS traversal through reverse dependency graph
//! @param changed_path The file that changed
void invalidate_transitive(string changed_path) {
    // Guard clause: only run if file exists in dependency index
    if (!dependents[changed_path] && !dependencies[changed_path]) {
        return;
    }

    array(string) queue = ({changed_path});
    multiset(string) visited = (<changed_path>);

    while (sizeof(queue) > 0) {
        string path = queue[0];
        queue = queue[1..];

        // Remove from cache
        m_delete(compilation_cache, path);

        // Remove from dependency graphs
        if (dependencies[path]) {
            foreach (dependencies[path], string dep) {
                if (dependents[dep]) {
                    dependents[dep][path] = 0;
                }
            }
            m_delete(dependencies, path);
        }

        // Add all dependents to queue
        if (dependents[path]) {
            foreach (indices(dependents[path]), string dependent) {
                if (!visited[dependent]) {
                    visited[dependent] = 1;
                    queue += ({dependent});
                }
            }
        }
    }
}
```

The guard clause prevents unnecessary work when a file with no dependents changes.
  </action>
  <verify>grep -q "invalidate_transitive\|BFS\|queue.*visited\|dependents\[path\]" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>Transitive invalidation traverses dependency graph via BFS</done>
</task>

<task type="auto">
  <name>Expose dependency tracking via CompilationResult</name>
  <files>pike-scripts/LSP.pmod/CompilationCache.pmod</files>
  <action>
Update CompilationResult to include dependencies:

1. Add dependencies field to class:
   ```pike
   class CompilationResult {
       program compiled_program;
       array(mapping) diagnostics;
       array(string) dependencies;  // New field

       void create(program prog, array(mapping) diags, array(string) deps) {
           compiled_program = prog;
           diagnostics = diags;
           dependencies = deps || ({});
       }
   }
   ```

2. Update put() to call update_dependency_graph:
   ```pike
   void put(string path, string version_key, CompilationResult result) {
       // ... existing eviction logic ...

       // Update dependency graph with new dependencies
       if (result->dependencies && sizeof(result->dependencies) > 0) {
           update_dependency_graph(path, result->dependencies);
       }

       // ... store in cache ...
   }
   ```

3. Add invalidate_transitive() wrapper that also removes from cache:
   The invalidate_transitive() method already handles cache removal via m_delete(compilation_cache, path).

4. Update invalidate() to also trigger transitive invalidation:
   ```pike
   void invalidate(string path, void|int transitive) {
       if (transitive) {
           invalidate_transitive(path);
       } else {
           m_delete(compilation_cache, path);
       }
   }
   ```
  </action>
  <verify>grep -q "dependencies.*array.*string\|update_dependency_graph.*path.*result" pike-scripts/LSP.pmod/CompilationCache.pmod</verify>
  <done>CompilationResult carries dependencies; put() updates graph; invalidate() supports transitive mode</done>
</task>

</tasks>

<verification>
1. Module compiles: `pike -e 'mixed m = master()->resolv("LSP.CompilationCache"); werror("CompilationCache: %s\n", m ? "loaded" : "failed");'`
2. Dependency graph updates correctly: Create entry, update with new deps, verify old edges removed
3. Transitive invalidation works: Invalidate A, verify B and C (which depend on A) are also invalidated
4. Local file filtering: stdlib dependencies are not tracked in graph
5. BFS traversal: Queue correctly processes all dependents without infinite loops
</verification>

<success_criteria>
1. DependencyTrackingCompiler captures dependencies during compilation
2. update_dependency_graph maintains accurate forward/reverse edges
3. invalidate_transitive removes all transitive dependents from cache
4. Local file filtering prevents stdlib modules from polluting the graph
5. No stale edge accumulation (old edges removed on recompile)
</success_criteria>

<output>
After completion, create `.planning/phases/13-pike-side-compilation-caching/13-02-SUMMARY.md`
</output>
