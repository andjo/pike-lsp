---
phase: 13-pike-side-compilation-caching
plan: 03
type: execute
wave: 3
depends_on: [13-01, 13-02]
files_modified:
  - pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
  - pike-scripts/analyzer.pike
  - packages/pike-bridge/src/bridge.ts
autonomous: true

must_haves:
  truths:
    - "handle_analyze checks CompilationCache before compiling"
    - "Cache hit returns cached CompilationResult immediately"
    - "Cache miss compiles and stores result in cache"
    - "LSP version parameter passed through for open document tracking"
    - "Transitive invalidation triggered when file changes"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      provides: "Cache-integrated handle_analyze method"
      contains: "CompilationCache.*get|put|invalidate"
    - path: "pike-scripts/analyzer.pike"
      provides: "CompilationCache initialization in Context"
      contains: "CompilationCache"
    - path: "packages/pike-bridge/src/bridge.ts"
      provides: "documentVersion parameter in analyze() method"
      contains: "documentVersion"
  key_links:
    - from: "packages/pike-lsp-server/src/features/diagnostics.ts"
      to: "packages/pike-bridge/src/bridge.ts"
      via: "bridge.analyze(text, operations, filename, documentVersion)"
      pattern: "analyze.*documentVersion"
    - from: "packages/pike-bridge/src/bridge.ts"
      to: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      via: "JSON-RPC analyze request with version parameter"
      pattern: "params.*version"
    - from: "pike-scripts/LSP.pmod/Analysis.pmod/module.pmod"
      to: "pike-scripts/LSP.pmod/CompilationCache.pmod"
      via: "CompilationCache module lookup and cache operations"
      pattern: "CompilationCache.*get|put"
---

<objective>
Integrate CompilationCache into handle_analyze flow for Pike-side caching

Purpose: Modify the analysis pipeline to check cache before compiling and store results after compilation. Enable TypeScript side to pass document version for open document tracking (avoiding stat overhead).

Output: Cache-aware handle_analyze, Context with CompilationCache, TypeScript bridge with version parameter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-pike-side-compilation-caching/13-CONTEXT.md
@.planning/phases/13-pike-side-compilation-caching/13-RESEARCH.md
@.planning/phases/13-pike-side-compilation-caching/13-01-SUMMARY.md
@.planning/phases/13-pike-side-compilation-caching/13-02-SUMMARY.md
@.planning/phases/12-request-consolidation/12-04-SUMMARY.md
@pike-scripts/LSP.pmod/Analysis.pmod/module.pmod
@pike-scripts/analyzer.pike
@packages/pike-bridge/src/bridge.ts
@packages/pike-lsp-server/src/features/diagnostics.ts
</context>

<tasks>

<task type="auto">
  <name>Add CompilationCache to Context</name>
  <files>pike-scripts/analyzer.pike</files>
  <action>
Update Context class in analyzer.pike to include CompilationCache:

1. Add compilation_cache field:
   ```pike
   class Context {
       mixed parser;
       mixed intelligence;
       mixed analysis;
       mixed compilation_cache;  // New field
       int debug_mode;
       mapping client_capabilities;

       void create() {
           // ... existing module initialization ...

           // Initialize CompilationCache
           mixed CacheClass = master()->resolv("LSP.CompilationCache");
           if (CacheClass && programp(CacheClass)) {
               compilation_cache = CacheClass();
           } else {
               compilation_cache = 0;
           }
       }
   }
   ```

2. Add get_compilation_cache() helper for lazy access:
   ```pike
   //! Get the CompilationCache instance, initializing if needed
   protected object get_compilation_cache(Context ctx) {
       if (!ctx->compilation_cache) {
           mixed CacheClass = master()->resolv("LSP.CompilationCache");
           if (CacheClass && programp(CacheClass)) {
               ctx->compilation_cache = CacheClass();
           }
       }
       return ctx->compilation_cache;
   }
   ```

3. Pass Context to handle_analyze (already done via dispatch table).

This ensures CompilationCache is available to all handlers that need it.
  </action>
  <verify>grep -q "compilation_cache\|CompilationCache" pike-scripts/analyzer.pike</verify>
  <done>Context includes CompilationCache instance accessible to all handlers</done>
</task>

<task type="auto">
  <name>Integrate cache into handle_analyze compilation path</name>
  <files>pike-scripts/LSP.pmod/Analysis.pmod/module.pmod</files>
  <action>
Update handle_analyze in module.pmod to use CompilationCache:

1. At the start of handle_analyze, extract optional version parameter:
   ```pike
   mapping handle_analyze(mapping params) {
       string code = params->code || "";
       string filename = params->filename || "input.pike";
       array(string) include = params->include || ({});
       int|string lsp_version = params->version;  // New: LSP version for open docs

       // ... rest of existing code ...
   ```

2. Replace the compilation section with cache-aware version:
   ```pike
       // Step 2: Compilation (only for introspect)
       if (has_value(valid_include, "introspect")) {
           object compile_timer = System.Timer();

           // Get CompilationCache from Context (passed via params->ctx or global)
           object cache = get_compilation_cache_from_context(params);

           // Generate cache key
           string cache_key = 0;
           if (cache) {
               cache_key = cache->make_cache_key(filename, lsp_version);
           }

           // Check cache
           program compiled_prog = 0;
           LSP.CompilationCache.CompilationResult cached_result = 0;

           if (cache && cache_key) {
               cached_result = cache->get(filename, cache_key);
               if (cached_result && cached_result->compiled_program) {
                   compiled_prog = cached_result->compiled_program;
                   // Cache hit - compilation_ms is 0 for cached compile
                   compilation_ms = 0.0;
               }
           }

           // Cache miss - compile
           if (!compiled_prog) {
               object compile_timer2 = System.Timer();
               mixed compile_err = catch {
                   compiled_prog = compile_string(code, filename);
               };
               compilation_ms = compile_timer2->peek() * 1000.0;

               if (compile_err || !compiled_prog) {
                   failures->introspect = ([
                       "message": describe_error(compile_err || "Compilation failed"),
                       "kind": "CompilationError"
                   ]);
               } else if (cache && cache_key) {
                   // Store in cache
                   LSP.CompilationCache.CompilationResult result =
                       LSP.CompilationCache.CompilationResult(compiled_prog, ({}), ({}));
                   cache->put(filename, cache_key, result);
               }
           }
       }
   ```

3. Add helper to get cache from Context:
   ```pike
   //! Get CompilationCache from Context (if available)
   protected object get_compilation_cache_from_context(mapping params) {
       // Try to get from params->ctx first, otherwise resolve
       if (params->ctx && params->ctx->compilation_cache) {
           return params->ctx->compilation_cache;
       }
       mixed CacheClass = master()->resolv("LSP.CompilationCache");
       if (CacheClass && programp(CacheClass)) {
           // Return the class (static methods) or create instance
           // LSP.CompilationCache uses module-level state, so class methods work
           return CacheClass;
       }
       return 0;
   }
   ```

4. Add cache_hit flag to performance metadata:
   ```pike
           if (cache_key) {
               perf->cache_key = cache_key;
               perf->cache_hit = (cached_result != 0);
           }
   ```

Note: For now, dependencies array is empty ({}). Plan 13-02's DependencyTrackingCompiler integration can be added later.
  </action>
  <verify>grep -q "make_cache_key\|cache->get\|cache->put\|cache_hit" pike-scripts/LSP.pmod/Analysis.pmod/module.pmod</verify>
  <done>handle_analyze checks cache before compiling and stores results on cache miss</done>
</task>

<task type="auto">
  <name>Add documentVersion parameter to TypeScript bridge</name>
  <files>packages/pike-bridge/src/bridge.ts</files>
  <action>
Update PikeBridge.analyze() method to accept optional documentVersion:

1. Update method signature:
   ```typescript
   async analyze(
       code: string,
       include: AnalysisOperation[],
       filename?: string,
       documentVersion?: number  // New parameter
   ): Promise<AnalyzeResponse> {
   ```

2. Pass documentVersion to Pike RPC:
   ```typescript
       return this.sendRequest<AnalyzeResponse>('analyze', {
           code,
           include,
           filename: filename || 'input.pike',
           version: documentVersion  // Pass LSP version for cache key
       });
   ```

3. Update JSDoc comment:
   ```typescript
    * @param documentVersion - Optional LSP document version (for cache invalidation)
    *                          If provided, cache uses LSP version instead of file stat
   ```

This enables the "dual-path" cache key strategy: open docs use LSP version (no stat), closed files use stat.
  </action>
  <verify>grep -q "documentVersion\|version: documentVersion" packages/pike-bridge/src/bridge.ts</verify>
  <done>bridge.analyze() accepts documentVersion and passes to Pike as version parameter</done>
</task>

<task type="auto">
  <name>Update diagnostics feature to pass document version</name>
  <files>packages/pike-lsp-server/src/features/diagnostics.ts</files>
  <action>
Update validateDocument() to pass document.version to bridge.analyze():

1. Extract version from TextDocument:
   ```typescript
       const text = document.getText();
       const version = document.version;  // Already available
       const filename = decodeURIComponent(uri.replace(/^file:\/\//, ''));
   ```

2. Pass to analyze call:
   ```typescript
       const response = await bridge.analyze(
           text,
           ['parse', 'introspect', 'diagnostics'],
           filename,
           version  // Pass LSP version for cache key
       );
   ```

3. Log cache hit/miss for debugging:
   ```typescript
       if (response.result?._perf) {
           const cacheHit = response.result._perf.cache_hit;
           connection.console.log(`[VALIDATE] Cache ${cacheHit ? 'HIT' : 'MISS'} for ${uri}`);
       }
   ```

This enables cache hits for open documents without filesystem stat overhead.
  </action>
  <verify>grep -q "bridge.analyze.*version\|cache.*HIT.*MISS" packages/pike-lsp-server/src/features/diagnostics.ts</verify>
  <done>validateDocument passes document version to enable open-doc caching</done>
</task>

</tasks>

<verification>
1. Cache hit on repeated analyze: Call analyze twice with same code/version, verify second call returns cache_hit=true
2. Cache miss on version change: Change version number, verify cache_hit=false
3. Cache miss on content change: Change code content, verify cache_hit=false
4. CompilationCache statistics: Verify stats->hits and stats->misses increment
5. Open document tracking: Verify make_cache_key uses LSP version when provided
6. Fallback without cache: If CompilationCache unavailable, analysis still works (graceful degradation)
</verification>

<success_criteria>
1. Second request for unchanged file is faster (cache hit)
2. Document version changes trigger cache miss (recompile)
3. File content changes trigger cache miss (different stat key)
4. Performance metadata includes cache_hit flag
5. Graceful degradation if cache unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/13-pike-side-compilation-caching/13-03-SUMMARY.md`
</output>
